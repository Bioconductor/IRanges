%\VignetteIndexEntry{An Introduction to IRanges}
%\VignetteDepends{}
%\VignetteKeywords{Ranges}
%\VignettePackage{IRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\IRanges}{\Rpackage{IRanges}}

\title{An Introduction to \Rpackage{IRanges}}
\author{Patrick Aboyoun, Michael Lawrence, Herv\'e Pag\`es}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=60)
@

% outline may need tweaking to be more example-oriented

\section{Introduction}

The \IRanges{} package is designed to represent sequences, ranges representing
indices along those sequences, and data related to those ranges. In
this vignette, we will rely on simple, illustrative example datasets,
rather than large, real-world data, so that each data structure and
algorithm can be explained in an intuitive, graphical manner.  We
expect that packages that apply IRanges to a particular problem domain
will provide vignettes with relevant, realistic examples.

\section{Sequences}

The \Rpackage{IRanges} package is primarily interested in the
representation, manipulation and analysis of sequences. A
\textit{sequence} is mathematically defined as an ordered list of
objects, or elements. It differs from a \textit{set} in that order
matters and the same element can appear multiple times. 

\Rpackage{IRanges} supports the use of R vectors to represent
sequences, and we also formally define a virtual class
\Rclass{Sequence}, the derivatives of which convey the sequence
semantic of ordered elements. There are currently two
\Rclass{Sequence} implementations in \Rpackage{IRanges}: \Rclass{Rle},
which compresses a sequence through run-length encoding, and
\Rclass{XSequence}, which refers to its data through an external
pointer. \Rclass{XSequence} and its derivatives are considered
low-level infrastructure and, as such, will not be covered by this
vignette.

We begin our demonstration by loading the \Rpackage{IRanges} package.
<<initialize, results=hide>>=
library(IRanges)
@

\subsection{Run Length Encoding}

% sparse representation, and more (manipulating runs is useful)

The \Rclass{Rle} class represents a run-length encoded (compressed) sequence of
\Rclass{logical}, \Rclass{integer}, \Rclass{numeric}, \Rclass{complex}, 
\Rclass{character}, or \Rclass{raw} values.

<<Rle-construction>>=
set.seed(0)
lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500), seq(10,0.001, length = 500))
x <- Rle(rpois(1e7, lambda))
y <- Rle(rpois(1e7, lambda[c(251:length(lambda), 1:250)]))
x
y
@

<<Rle-accessors>>=
head(runValue(x))
head(runLength(x))
@

<<Rle-ops>>=
x > 0
x + y
x > 0 | y > 0
@


<<Rle-summary>>=
range(x)
sum(x > 0 | y > 0)
@

<<Rle-math>>=
log1p(x)
@


<<Rle-cor>>=
cor(x, y)
shiftApply(249:251, y, x, FUN = function(x, y) var(x, y) / (sd(x) * sd(y)))
@


<<Rle-rollmean>>=
rollmeanRle <- function (x, k)
{
    n <- length(x)
    cumsum(c(Rle(sum(subseq(x, 1, k))), subseq(x, k + 1, n) - subseq(x, 1, n - k))) / k
}
@


<<Rle-rollvar>>=
rollvarRle <- function(x, k)
{
    n <- length(x)
    means <- rollmeanRle(x, k)
    nextMean <- subseq(means, 2, n - k + 1)
    cumsum(c(Rle(sum((subseq(x, 1, k) - means[1])^2)),
             k * diff(means)^2 -
               (subseq(x, 1, n - k) - nextMean)^2 +
                 (subseq(x, k + 1, n) - nextMean)^2)) / (k - 1)
}
@


<<Rle-rollcov>>=
rollcovRle <- function(x, y, k)
{
    n <- length(x)
    meanX <- rollmeanRle(x, k)
    meanY <- rollmeanRle(y, k)
    nextMeanX <- subseq(meanX, 2, n - k + 1)
    nextMeanY <- subseq(meanY, 2, n - k + 1)
    cumsum(c(Rle(sum((subseq(x, 1, k) - meanX[1]) * (subseq(y, 1, k) - meanY[1]))),
             k * diff(meanX) * diff(meanY) -
               (subseq(x, 1, n - k) - nextMeanX) * (subseq(y, 1, n - k) - nextMeanY) +
                 (subseq(x, k + 1, n) - nextMeanX) * (subseq(y, k + 1, n) - nextMeanY))) / (k - 1)
}
@


<<Rle-rollsd>>=
rollsdRle <- function(x, k)
{
    sqrt(rollvarRle(x, k))
}
@


<<Rle-rollcor>>=
rollcorRle <- function(x, y, k)
{
    rollcovRle(x, y, k) / (rollsdRle(x, k) * rollsdRle(y, k))
}
@

\section{Lists}

\subsection{Basic operations}

One often wants to organize and manipulate multiple sequences
simultaneously. We could place multiple \Rclass{Rle} instances, for
example, into a list. However, a list is too generic; it does not
confer any information about the specific class of its elements. There
is no type-safety, and it is not possible to define methods
specifically for homogeneous lists with elements of a particular
class. For example, for a list of \Rclass{Rle} objects, we may wish to
define a method that retrieves the run values for each element,
without special type checking. To enable this, we define a specific
collection class, \Rclass{RleList}, for storing \Rclass{Rle} objects.

%% EXAMPLE (construct RleList)

In fact, we have done the same for many of the other classes in
\Rpackage{IRanges}, and all of the collection classes derive from the
virtual class \Rclass{ListLike}, the derivatives of which are all
obligated to support two basic list operations: element extraction and
length retrieval. 

%% EXAMPLE (element extraction, length)

Most collection types, including \Rclass{RleList}, derive from
\Rclass{TypedList}, a \Rclass{ListLike} derivative that implements
the requisite operations, as well as a number of additional
features. These include familiar list functions, such as
\Rfunction{c} and \Rfunction{lapply}.

%% EXAMPLE (c, lapply)

\subsection{Advanced Notes}

%% Perhaps this belongs in a separate advanced vignette or the paper?

\Rclass{TypedList} also provides some more advanced features. First,
as its name suggests, subclasses of \Rclass{TypedList} can specify a
type from which the class of each of its elements must inherit. For
example, \Rclass{RleList} directs \Rclass{TypedList} to ensure that
all of its elements are \Rclass{Rle} objects. One benefit of this type
safety is that it allows methods dispatching on \Rclass{RleList} to
assume that all of the elements are really of class \Rclass{Rle}.

A second advanced feature of \Rclass{TypedList} relates to its
internal representation. Behind the scenes, \Rclass{TypedList} is
simply an R \Rclass{list}. By default, there is a one-to-one mapping
between elements of the \Rclass{TypedList} and elements in the
\Rclass{list}. This is a simple design; however, it is not always
ideal. If one has many, small objects, the storage overhead,
especially for S4 objects, would be relatively high.

For example, assume we need to represent a million sequences. We might
then construct a million \Rclass{Rle} objects and place them into an
\Rclass{RleList}. 

\subsection{Simple Lists}

\Rclass{LogicalList}
\Rclass{IntegerList}
\Rclass{NumericList}
\Rclass{ComplexList}
\Rclass{CharacterList}
\Rclass{RawList}
\Rclass{RleList}

\subsection{Annotated Lists}

\Rclass{AnnotatedList}


\section{Sequence Ranges}

% encode subsequences
% entire object could encode subsequence, eg subsetting Rle
% or, each range encodes a subsequence, resulting in many (Views)

% introduce basic ranges functionality, eg starts, widths, subsetting

\Rclass{Ranges}
\Rclass{IRanges}
\Rclass{NormalIRanges}
\Rclass{RangesList}
\Rclass{IRangesList}
\Rclass{MaskCollection} % make distinction with RangesList

\Rclass{IntervalTree}
% need an IntervalTreeList?

\subsection{Transforming Ranges}

% most utilities fall in here
\Rfunction{reduce}
\Rfunction{shift}
\Rfunction{restrict}
\Rfunction{narrow}
\Rfunction{reflect}
\Rfunction{flank}
\Rfunction{*} % zooming

\Rfunction{disjoin}, \Rfunction{disjointBins}

\subsection{Set Operations}

\Rfunction{gaps}, \Rfunction{pgaps}
\Rfunction{setdiff}, \Rfunction{psetdiff}
\Rfunction{union}, \Rfunction{punion}
\Rfunction{intersect}, \Rfunction{pintersect}

\subsection{Finding Overlapping Ranges}

\Rclass{RangesMatching}
\Rclass{RangesMatchingList}

\Rfunction{overlap}, \Rfunction{\%in\%}

\subsection{Finding Neighboring Ranges}

\Rfunction{nearest}, \Rfunction{precede}, \Rfunction{follow}

\section{Sequence Views}

% when each range in a Ranges encodes a subsequence, need to
% manipulate many, possibly overlapping, subsequences

\Rclass{Views}
\Rclass{RleViews}

\subsection{Manipulating Views}

\subsection{Aggregating Views}


\section{Data Sets}

\Rclass{XDataFrame}
\Rclass{XDataFrameList}
\Rclass{SplitXDataFrameList}

\section{Sequence Ranges with Data Sets}

\Rclass{RangedData}
\Rclass{RangedDataList}

\subsection{Applying Over Spaces}

\Rclass{RDApplyParams}
\Rclass{FilterRules}

%% Classes Not Covered (18)
%%\Rclass{Alignment}
%%\Rclass{AlignmentSpace}
%%\Rclass{ANYTHING}
%%\Rclass{characterORNULL}
%%\Rclass{expressionORfunction}
%%\Rclass{expressionORlanguage}
%%\Rclass{functionORNULL}
%%\Rclass{IntegerPtr}
%%\Rclass{NumericPtr}
%%\Rclass{RangesORmissing}
%%\Rclass{RawPtr}
%%\Rclass{SequencePtr}
%%\Rclass{vectorORfactor}
%%\Rclass{XDataFrameORNULL}
%%\Rclass{XInteger}
%%\Rclass{XIntegerORNULL}
%%\Rclass{XIntegerViews}
%%\Rclass{XNumeric}

\begin{table*}[tbp]
\begin{minipage}{\textwidth}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@ 
\end{minipage}
\caption{\label{tab:sessioninfo}%
The output of \Rfunction{sessionInfo} on the build system 
after running this vignette.}
\end{table*}

\end{document}
