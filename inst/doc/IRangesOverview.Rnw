%\VignetteIndexEntry{An Introduction to IRanges}
%\VignetteDepends{}
%\VignetteKeywords{Ranges}
%\VignettePackage{IRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\IRanges}{\Rpackage{IRanges}}

\title{An Introduction to \IRanges{}}
\author{Patrick Aboyoun, Michael Lawrence, Herv\'e Pag\`es}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=72)
@

\section{Introduction}

The \IRanges{} package is designed to represent sequences, ranges
representing indices along those sequences, and data related to those
ranges. In this vignette, we will rely on simple, illustrative example
datasets, rather than large, real-world data, so that each data structure
and algorithm can be explained in an intuitive, graphical manner. We
expect that packages that apply \IRanges{} to a particular problem domain
will provide vignettes with relevant, realistic examples.

The term \textit{sequence} in the \IRanges{} package is used rather loosely,
much like the term \textit{vector} is in \R{}. We use sequence to mean an
indexed collection of elements or objects. This differs from the standard
mathematical definition of a logically ordered collection of elements. We
will refer to the latter definition as a \textit{mathematical sequence} to
minimize the confusion.

The \IRanges{} package is available at bioconductor.org and can be
downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("IRanges")
@
<<initialize, results=hide>>=
library(IRanges)
@

\section{Sequences}

The \IRanges{} packages represents three types of objects as sequences:
mathematical sequences, lists, and data tables (so they behave like \R{}'s
\Rclass{data.frame} objects). The following subsections describe each in
turn. All \IRanges{}-derived sequences inherit from the \Rclass{Sequence}
virtual class.

\subsection{Mathematical Sequences}

As mentioned in the introduction, a mathematical sequence is a logically
ordered collection of elements. In \R{}, mathematical sequences are
typically stored in atomic vectors. The \IRanges{} package includes two
additional mathematical sequence object types:  \Rclass{Rle}, which
compresses a mathematical sequence through run-length encoding, and
\Rclass{XSequence}, which refers to its data through an external
pointer. \Rclass{XSequence} and its derivatives are considered low-level
infrastructure and, as such, will not be covered by this vignette.

We begin our discussion of mathematical sequences using two \R{} 
\Rclass{integer} vectors.
<<initialize>>=
set.seed(0)
lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500), seq(10, 0.001, length = 500))
xVector <- rpois(1e7, lambda)
yVector <- rpois(1e7, lambda[c(251:length(lambda), 1:250)])
@

All mathematical sequences in \R{} have three main properties: (1) a
notion of length or number of elements, (2) the ability to extract
elements to create new mathematical sequences, and (3) the ability to be
combined with one or more mathematical sequences to form larger
mathematical sequences. The main functions for these three operations are
\Rfunction{length}, \Rfunction{[}, and \Rfunction{c}.
<<basic-ops>>=
length(xVector)
xVector[1]
zVector <- c(xVector, yVector)
@

While these three methods may seem trivial, they provide a great deal of
power and many mathematical sequence manipulations can be constructed
using them.

\subsubsection{Mathematical Sequence Extraction}

As with ordinary \R{} atomic vectors, it is often necessary to extract one
mathematical sequence from another. When this extraction doesn't change the
order of the elements being extracted, the result is called a
mathematical \textit{subsequence}. In general, the \Rfunction{[} function
can be used to construct a new mathematical sequence or extract a
mathematical subsequence, but often times it isn't convenient or
performant enough for the use case at hand. To compensate for this, the
\IRanges{} package supports six additional functions for mathematical
sequence extraction:

\begin{enumerate}
\item \Rfunction{window} - Produces a mathematical subsequence over a
  specified region with or without regular interval subsampling.
\item \Rfunction{seqextract} - Concatenates multiple consecutive
  mathematical subsequences into a new mathematical subsequence. The result
  may or may not be a mathematical subsequence.
\item \Rfunction{head} - Extracts a consecutive mathematical subsequence
  containing the first n elements.
\item \Rfunction{tail} - Extracts a consecutive mathematical subsequence
  containing the last n elements.
\item \Rfunction{rev} - Creates a new mathematical sequence with the
  elements in the reverse order.
\item \Rfunction{rep} - Creates a new mathematical sequence by repeating
  mathematical sequence elements.
\end{enumerate}

The following code illustrates how these functions are used on an
ordinary \R{} \Rclass{integer} vector:

<<seq-extraction>>=
xSnippet <- window(xVector, start = 4751, end = 4760)
xSnippet
head(xSnippet)
rev(xSnippet)
window(xSnippet, delta = 2)
seqextract(xSnippet, start = c(6,1), end = c(10, 5))
rep(xSnippet, 2)
@

\subsubsection{Looping over Mathematical Subsequences}

In \R{}, \Rfunction{for} looping can be an expensive operation. To
compensate for this, \IRanges{} provides two functions,
\Rfunction{aggregate} and \Rfunction{shiftApply}, to perform calculations
over mathematical subsequences. The \Rfunction{aggregate} function combines
mathematical sequence extraction functionality of the \Rfunction{window}
function with looping capabilities of the \Rfunction{sapply} function. For
example, here is some code to compute medians across a moving window of
width 3 using the function \Rfunction{aggregate}:

<<aggregate>>=
xSnippet
aggregate(xSnippet, start = 1:8, width = 3, FUN = median)
@

The \Rfunction{shiftApply} function is a looping operation involving two
mathematical sequences whose elements are lined up via a positional shift
operation. For example, the elements of \Robject{xVector} and
\Robject{yVector} were simulated from Poisson distributions with the mean
of element i from \Robject{yVector} being equivalent to the mean of element
i + 250 from \Robject{xVector}. If we did not know the size of the shift,
we could estimate it by finding the shift that maximizes the correlation 
between \Robject{xVector} and \Robject{yVector}.

<<shiftApply-cor>>=
cor(xVector, yVector)
shifts = seq(235, 265, by=3)
corrs  = shiftApply(shifts, yVector, xVector, FUN = cor)
@
%
<<figshiftcorrs, fig=TRUE, include=FALSE, eps=FALSE, width=5, height=5>>=
plot(shifts, corrs)
@ 

The result is shown in Fig.~\ref{figshiftcorrs}.
\begin{figure}[tb]
  \begin{center}
     \includegraphics[width=0.5\textwidth]{IRangesOverview-figshiftcorrs}  
     \caption{\label{figshiftcorrs}%
      Correlation between \Robject{xVector} and \Robject{yVector} for various
      shifts.}
  \end{center}
\end{figure}


\subsubsection{Run Length Encoding}

Up until this point we have used \R{} atomic vectors to represent
mathematical sequences, but there are times when these object become too
large to manage in memory. When there are lots of consecutive repeats in
the mathematical sequence, the data can be compressed and managed in memory
through a run-length encoding where a data value is paired with a run
length. For example, the sequence \{1, 1, 1, 2, 3,  3\} can be represented
as values = \{1, 2, 3\}, run lengths = \{3, 1, 2\}.

The \Rclass{Rle} class in \IRanges{} is used to represent a run-length
encoded (compressed) mathematical sequence of \Rclass{logical},
\Rclass{integer}, \Rclass{numeric}, \Rclass{complex},  \Rclass{character},
or \Rclass{raw} values. One way to construct an \Rclass{Rle} object is
through the \Rclass{Rle} constructor function:

<<Rle-construction>>=
xRle <- Rle(xVector)
yRle <- Rle(yVector)
xRle
yRle
@

When there are lots of consecutive repeats, the memory savings through
an RLE can be quite dramatic. For example, the \Robject{xRle} object
occupies less than one quarter of the space of the original \Robject{xVector}
object, while storing the same information:

<<Rle-vector-compare>>=
as.vector(object.size(xRle) / object.size(xVector))
identical(as.vector(xRle), xVector)
@

The functions \Rfunction{runValue} and \Rfunction{runLength} extract
the run values and run lengths from an \Rclass{Rle} object respectively:

<<Rle-accessors>>=
head(runValue(xRle))
head(runLength(xRle))
@

The \Rclass{Rle} class supports many of the basic methods associated with
\R{} atomic vectors including the Ops, Math, Math2, Summary, and Complex
group generics. Here is a example of manipulating \Rclass{Rle} objects
using methods from the Ops group:

<<Rle-ops>>=
xRle > 0
xRle + yRle
xRle > 0 | yRle > 0
@

Here are some from the Summary group:

<<Rle-summary>>=
range(xRle)
sum(xRle > 0 | yRle > 0)
@

And here is one from the Math group:

<<Rle-math>>=
log1p(xRle)
@

As with the atomic vectors, the \Rfunction{cor} and \Rfunction{shiftApply}
functions operate on \Rclass{Rle} objects:

<<Rle-cor>>=
cor(xRle, yRle)
shiftApply(249:251, yRle, xRle, FUN = function(x, y) var(x, y) / (sd(x) * sd(y)))
@

For more information on the methods supported by the \Rclass{Rle} class,
consult the \Rcode{Rle} man page.

\subsection{Lists}

\subsubsection{Basic operations}

One often wants to organize and manipulate multiple sequences
simultaneously. We could place multiple \Rclass{Rle} instances, for
example, into a list. However, a list is too generic; it does not
confer any information about the specific class of its elements. There
is no type safety, and it is not possible to define methods
specifically for homogeneous lists with elements of a particular
class. For example, for a list of \Rclass{Rle} objects, we may wish to
define a method that retrieves the run values for each element,
without special type checking. To enable this, we define a specific
collection class, \Rclass{RleList}, for storing \Rclass{Rle} objects.

%% EXAMPLE (construct RleList)

In fact, we have done the same for many of the other classes in
\IRanges{}, as well as the base atomic vectors (raw, logical,
integer, numeric, complex and character). All of the collection
classes derive from the virtual class \Rclass{Sequence}, the
derivatives of which are all obligated to support two basic list
operations: element extraction and length retrieval.

%% EXAMPLE (element extraction, length)

Most collection types, including \Rclass{RleList}, derive from
\Rclass{TypedList}, a \Rclass{Sequence} derivative that implements
the requisite operations, as well as a number of additional
features. These include familiar list functions, such as
\Rfunction{c} and \Rfunction{lapply}.

%% EXAMPLE (c, lapply)

\subsubsection{Annotated Lists} 

Often when one has a collection of objects, there is a need to attach
metadata that describes the collection in some way. The
\Rclass{AnnotatedList} class extends \Rclass{TypedList} to add two
metadata components: an ordinary \Rclass{list} to hold arbitary
objects, called \Robject{metadata}, and \Robject{elementMetadata}, a
data frame with one row per element and any number of columns. Many of
the high-level list objects in \IRanges{} (described later) are
\Rclass{AnnotatedList} objects.
% FIXME (wh 26.5.09): this description does not seem to correspond to the
% current implementation of the package?

\subsubsection{Advanced Notes}

%% Perhaps this belongs in a separate advanced vignette or the paper?

\Rclass{TypedList} also provides some more advanced features. First,
as its name suggests, subclasses of \Rclass{TypedList} can specify a
type from which the class of each of its elements must inherit. For
example, \Rclass{RleList} directs \Rclass{TypedList} to ensure that
all of its elements are \Rclass{Rle} objects. One benefit of this type
safety is that it allows methods dispatching on \Rclass{RleList} to
assume that all of the elements are really of class \Rclass{Rle}.

A second advanced feature of \Rclass{TypedList} relates to its
internal representation. Behind the scenes, \Rclass{TypedList} is
simply an R \Rclass{list}. By default, there is a one-to-one mapping
between elements of the \Rclass{TypedList} and elements in the
\Rclass{list}. This is a simple design; however, it is not always
ideal. If one has many, small objects, the storage overhead,
especially for S4 objects, would be relatively high. Our solution is
to \textit{compress} the list by concatenating the elements together,
if possible. This forms a single, long element that is virtually split
by the \Rclass{TypedList} interface. A beneficial side effect of this
approach is that unlisting (concatenating all of the elements)
is cheap, as it reduces to returning the internal representation.

\subsection{Data Tables}

To Do:
\Rclass{DataFrame},
\Rclass{DataFrameList},
\Rclass{SplitDataFrameList}

\section{Sequence Ranges}

When analyzing sequences, we are often interested in particular
contiguous subsequences. For example, the \Sexpr{letters} vector could
be considered a sequence of lower-case letters, in alphabetical order.
We would call the first five letters (\textit{a} to \textit{e}) a
contiguous subsequence, while the subsequence containing only the
vowels would not be contiguous. It is not uncommon for an analysis
task to focus only on the geometry of the regions, while
ignoring the underlying sequence values. A list of indices would be a
simple way to select a subsequence. However, a sparser representation
for consecutive subsequences would be a range, a pairing of a start
position and a width, as used when extracting sequences with
\Rfunction{window} and \Rfunction{seqextract}, above.

When analyzing subsequences in \IRanges{}, each range is treated as an
observation. The virtual \Rclass{Ranges} class represents lists of
ranges, or, equivalently and as a derivative \Rclass{IntegerList},
sequences of consecutive integers. The most commonly used
implementation of \Rclass{Ranges} is \Rclass{IRanges}, which stores
the starts and widths as ordinary integer vectors. To construct an
\Rclass{IRanges} instance, we call the \Rfunction{IRanges}
constructor. Ranges are normally specified by passing two out of the
three parameters: start, end and width (see \Sexpr{help(IRanges)} for
more information).
%
<<iranges-constructor>>=
ir1 <- IRanges(start = 1:10, width = 10:1)
ir2 <- IRanges(start = 1:10, end = 11)
ir3 <- IRanges(end = 11, width = 10:1)
identical(ir1, ir2) & identical(ir2, ir3)
@ 
%
All of the above calls construct an \Rclass{IRanges} instance with the
same ranges, using different combinations of the \Rfunarg{start},
\Rfunarg{end} and \Rfunarg{width} parameters.

Accessing the starts, widths and ends is supported by every
\Rclass{Ranges} implementation.
<<iranges-start>>=
start(ir1)
@ 
<<iranges-end>>=
end(ir1)
@ 
<<iranges-width>>=
width(ir1)
@ 

For \Rclass{IRanges} and some other \Rclass{Ranges} derivatives,
subsetting is also supported, by numeric and logical indices.
<<iranges-subset-numeric>>=
ir <- ir1[1:5]
ir
@ 
<<iranges-subset-logical>>=
ir1[start(ir1) <= 5]
@ 

One may think of each range as a sequence of integer ranges, and
\Rclass{Ranges} is, in fact, derived from \Rclass{IntegerList}.
<<ranges-extraction>>=
ir1[[1]]
@ 

\subsection{Normality}

Sometimes, it is necessary to formally represent a true mathematical
subsequence, where no elements are repeated and order is
preserved. Also, it is occasionally useful to think of a
\Rclass{Ranges} object as a set, where no elements are repeated and
order does not matter. While every \Rclass{Ranges} object, as a
\Rclass{Sequence} derivative, has an implicit ordering, one can
enforce the same ordering for all such objects, so that ordering
becomes inconsequential within that context. 

The \Rclass{NormalIRanges} class formally represents either a
mathematical subsequence encoding or a set of integers. By definition
a Ranges object is said to be \textit{normal} when its ranges are: (a)
not empty (i.e. they have a non-null width); (b) not overlapping; (c)
ordered from left to right; (d) not even adjacent (i.e. there must be
a non empty gap between 2 consecutive ranges).

There are three main advantages of using a \textit{normal}
\Rclass{Ranges} object: (1) it guarantees a mathematical subsequence
encoding or set of integers, (2) it is compact in terms of the number
of ranges, and (3) it uniquely identifies its information, which
simplifies comparisons.

The \Rfunction{reduce} function reduces any \Rclass{Ranges} object to
a \Rclass{NormalIRanges} by merging redundant ranges.
<<ranges-reduce>>=
reduce(ir1)
@ 

\subsection{Lists of \Rclass{Ranges} objects}

As with \Rclass{Sequence} objects, it is common to manipulate
collections of \Rclass{Ranges} objects during an analysis. Thus, the
\IRanges{} package defines some specific classes for working with
multiple \Rclass{Ranges} objects.

The \Rclass{RangesList} class asserts that each element is a
\Rclass{Ranges} object and provides convenience methods, such as
\Rfunction{start}, \Rfunction{end} and \Rfunction{width} accessors
that return flat integer vectors, aligning with the unlisted form of
the \Rclass{RangesList}. To explicitly construct a
\Rclass{RangesList}, use the \Rfunction{RangesList} function.
<<rangeslist-contructor>>=
rl <- RangesList(ir, rev(ir))
@ 
%
<<rangeslist-start>>=
start(rl)
@ 

\subsection{Sequence Extraction}

As \Rclass{Ranges} objects encode subsequences, they may be used
directly in sequence extraction. Note that when a \textit{normal}
\Rclass{Ranges} is given as the index, the result is a true
subsequence, in the mathematical sense, as no elements are repeated or
reordered.
%
<<seqextract-ranges>>=
seqextract(xRle, ir1[1:2])
@
%
If the sequence is a \Rclass{Sequence} derivative (i.e. not an
ordinary \Rclass{vector}), the canonical \Rfunction{[} function also
accepts a \Rclass{Ranges} instance.
%
<<bracket-ranges>>=
xRle[ir1[1:2]]
@ 
%

\subsection{Finding Overlapping Ranges}

\Rclass{RangesMatching}
\Rclass{RangesMatchingList}
\Rclass{IntervalTree}

\Rfunction{overlap}, \Rfunction{\%in\%}

\subsection{Finding Neighboring Ranges}

\Rfunction{nearest}, \Rfunction{precede}, \Rfunction{follow}

\subsection{Transforming Ranges}

Utilities are available for transforming a \Rclass{Ranges} object in a
variety of ways. Some transformations, like \Rfunction{reduce}
introduced above, can be dramatic, while others are simple per-range
adjustments of the starts, ends or widths.

\subsubsection{Adjusting starts, ends and widths}

Perhaps the simplest transformation is to adjust the start values by a
scalar offset, as performed by the \Rfunction{shift} function. Below,
we shift all ranges forward 10 positions.
%
<<ranges-shift>>=
shift(ir, 10)
@

The arithmetic functions \Rfunction{+}, \Rfunction{-} and
\Rfunction{*} change both the start and the end/width by symetrically
expanding or contracting each range.  Adding or subtracting a numeric
(integer) vector to a \Rclass{Ranges} causes each range to be expanded
or contracted on each side by the corresponding value in the numeric
vector.
<<ranges-plus>>=
ir + 1:5
@ 
%
The \Rfunction{*} operator symetrically magnifies a \Rclass{Ranges}
object by a factor, where positive contracts (zooms in) and negative
expands (zooms out).
%
<<ranges-asterisk>>=
ir * -2 # half the width
@

There are several other ways to form subranges, besides symmetric
contraction.  These include \Rfunction{narrow}, \Rfunction{threebands}
and \Rfunction{restrict}.  \Rfunction{narrow} supports the adjustment
of start, end and width values, which should be relative to each
range. Unlike \Rfunction{shift}, these adjustments are vectorized over
the ranges. As its name suggests, the ranges can only be narrowed.
% 
<<ranges-narrow>>=
narrow(ir, start=1:5, width=2)
@
% 
The \Rfunction{threebands} function extends \Rfunction{narrow} so that
the remaining left and right regions adjacent to the narrowed region
are also returned in separate \Rclass{Ranges} objects.
<<ranges-threebands>>=
threebands(ir, start=1:5, width=2)
@ 

The \Rfunction{restrict} function ensures every range falls within a
set of bounds. Ranges are contracted as necessary, and the ranges that
fall completely outside of but not adjacent to the bounds are dropped,
by default.
<<ranges-restrict>>=
restrict(ir, start=2, end=3)
@ 

\subsubsection{Making ranges disjoint}

A more complex type of operation is making a set of ranges disjoint,
\textit{i.e.} non-overlapping. For example, \Rfunction{threebands}
returns a disjoint set of three ranges for each input range.

The \Rfunction{disjoin} function makes a \Rclass{Ranges} object
disjoint by fragmenting it into the widest ranges where the set of
overlapping ranges is the same.
<<ranges-disjoin>>=
disjoin(ir)
@ 
A variant of \Rfunction{disjoin} is \Rfunction{disjointBins}, which
divides the ranges into bins, such that the ranges in each bin are
disjoint. The return value is an integer vector of the bins.
<<ranges-disjointBins>>=
disjointBins(ir)
@ 

\subsubsection{Other transformations}

Other transformations include \Rfunction{reflect} and
\Rfunction{flank}. The former ``flips'' each range within a set of common
reference bounds.
<<ranges-reflect>>=
reflect(ir, IRanges(start(ir), width=width(ir)*2))
@ 
%
The \Rfunction{flank} returns ranges of a specified width that flank,
to the left (default) or right, each input range. One use case of this
is forming promoter regions for a set of genes.
<<ranges-flank>>=
flank(ir, width = 1:5)
@ 
%

\subsection{Set Operations}

Sometimes, it is useful to consider a \Rclass{Ranges} object as a set
of integers, although there is always an implicit ordering. This is
formalized by \Rclass{NormalIRanges}, above, and we now present
versions of the traditional mathematical set operations
\textit{complement}, \textit{union}, \textit{intersect}, and
\textit{difference} for \Rclass{Ranges} objects. There are two
variants for each operation. The first treats each \Rclass{Ranges}
object as a set and returns a \textit{normal} value, while the other
has a ``parallel'' semantic like \Rfunction{pmin}/\Rfunction{pmax} and
performs the operation for each range pairing separately.

The \textit{complement} operation is implemented by the
\Rfunction{gaps} and \Rfunction{pgap} functions. By default,
\Rfunction{gaps} will return the ranges that fall between the ranges
in the (normalized) input. It is possible to specify a set of bounds,
so that flanking ranges are included.
<<ranges-gaps>>=
gaps(ir, start=1, end=20)
@ 
\Rfunction{pgap} considers each parallel pairing between two
\Rclass{Ranges} objects and finds the range, if any, between
them. Note that the function name is singular, suggesting that only
one range is returned per range in the input.
<<ranges-pgap>>=
pgap(ir, ir2)
@ 

The remaining operations, \textit{union}, \textit{intersect} and
\textit{difference} are implemented by the \Rfunction{[p]union},
\Rfunction{[p]intersect} and \Rfunction{[p]setdiff} functions,
respectively. These are relatively self-explanatory.
<<ranges-union>>=
@ 
<<ranges-punion>>=
@ 
<<ranges-intersect>>=
@ 
<<ranges-pintersect>>=
@ 
<<ranges-setdiff>>=
@ 
<<ranges-psetdiff>>=
@ 

% \subsection{Mapping Ranges Between Sequences}

% \Rclass{RangesMapping}
% \Rfunction{map}

\section{Sequence Views}

When we extract a sequence with \Rfunction{seqextract}, we can pass
multiple ranges, each selecting a single consecutive
subsequence. Those subsequences are extracted and concatenated into a
single sequence. There are many cases where the user wishes to avoid
the concatenation step and instead treat each consecutive subsequence
as a separate element in a list.  

While one could simply store each extracted sequence as an element in
a list object like a \Rclass{TypedList}, this is undesirable for a
couple of reasons. First, the user often wants to preserve the
original sequence and declare a set of interesting regions as an
overlay. This allows retrieving sequence values even after the ranges
have been adjusted. Another benefit of an overlay approach is
performance: the sequence values need not be copied.

For representing such an overlay, the \IRanges{} package provides the
virtual \Rclass{Views} class, which derives from \Rclass{Ranges} but
also stores a sequence. Each range is said to represent a
\textit{view} onto the sequence.

Here, we will demonstrate the \Rclass{RleViews} class, where the
sequence is of class \Rclass{Rle}. Other \Rclass{Views}
implementations exist, such as \Rclass{XStringViews} in the
\Rpackage{Biostrings} package.

\subsection{Manipulating Views}

\subsection{Aggregating Views}


\section{Data on Ranges}

When analyzing ranges, there are often additional variables of
interest, besides the geometry (starts, ends and widths). To formally
represent a dataset where the ranges are the observations, \IRanges{}
defines the \Rclass{RangedData} class.

%\subsection{Manipulating \Rclass{RangedData}}

To create a \Rclass{RangedData} instance, one needs to provide a
\Rclass{Ranges} object and, optionally, any number of variables on
those ranges. The variable objects need not be vectors, but they must
satisfy the contract of \Rclass{DataFrame}.
<<RangedData-construct>>=
values <- rnorm(5)
rd <- RangedData(ir, name = letters[1:5], values)
rd
@

One might notice the term ``sequence'' in the above output. This
refers to an important feature of \Rclass{RangedData}: the ability to
segregate ranges by their sequence (or space). For example, when
analyzing genomic data, one is often working with ranges on different
chromosomes. In many cases, such as when calculating overlap, one
needs to separately treat ranges from different spaces, and
\Rclass{RangedData} aims to facilitate this mode of operation. The
segregation may be performed at construction time.
<<RangedData-construct-space>>=
rd <- RangedData(ir, name = letters[1:5], values, 
                 space = rep(c("chr1", "chr2"), c(2, 3)))
rd
@ 

With the knowledge that the data is split into spaces, it should not
be surprising that the \Rfunction{ranges} accessor returns a
\Rclass{RangesList} and \Rfunction{values} returns a
\Rclass{SplitDataFrameList}.
<<RangedData-ranges>>=
ranges(rd)
@
<<RangedData-values>>=
values(rd)
@ 

To obtain a \Rclass{RangedData} for a specific set of spaces, one should
use the \Rfunction{[} function, which accepts logical, numeric and
character indices.
<<RangedData-subspace>>=
rd["chr1"]
@
%
<<RangedData-subspace-2>>=
all(identical(rd["chr1"], rd[1]),
    identical(rd[1], rd[c(TRUE, FALSE)]))
@ 
The \Rfunction{names} and \Rfunction{length} functions return the
names and number of spaces, respectively.
<<RangedData-names>>=
names(rd)
@ 
<<RangedData-length>>=
length(rd)
@ 

The \Rfunction{lapply} function operates over the spaces. The object
passed to the user function is a subset \Rclass{RangedData}.
<<RangedData-lapply>>=
lapply(rd, names)
@ 

The above would suggest that \Rclass{RangedData} is a sequence of
spaces. However, \Rclass{RangedData} also inherits from
\Rclass{DataTable}, so it in some ways behaves like a sequence of
columns. For example, one can extract a column via \Rfunction{\$} or
\Rfunction{\[\[}.
<<RangedData-extract>>=
rd[[2]]
@
<<RangedData-dollar>>=
rd$values
@ 
Note that the extracted columns are ``unlisted'' over the spaces,
which is usually much more convenient than obtaining them as lists. It
is important to note that the elements have been sorted by
the space factor and thus may not have the same order as the
objects passed to the constructor.

The two dimensional matrix-style subsetting is also supported. The
rows are indexed globally, independent of space.
<<RangedData-subset-2d>>=
rd[1:3, "name"]
@ 

% \subsection{Applying Over Spaces}

% \Rclass{RDApplyParams}
% \Rclass{FilterRules}

%% Classes Not Covered (16)
%%\Rclass{ANYTHING}
%%\Rclass{characterORNULL}
%%\Rclass{expressionORfunction}
%%\Rclass{expressionORlanguage}
%%\Rclass{functionORNULL}
%%\Rclass{IntegerPtr}
%%\Rclass{NumericPtr}
%%\Rclass{RangesORmissing}
%%\Rclass{RawPtr}
%%\Rclass{SequencePtr}
%%\Rclass{vectorORfactor}
%%\Rclass{DataFrameORNULL}
%%\Rclass{XInteger}
%%\Rclass{XIntegerORNULL}
%%\Rclass{XIntegerViews}
%%\Rclass{XNumeric}

\begin{table*}[tbp]
\begin{minipage}{\textwidth}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@ 
\end{minipage}
\caption{\label{tab:sessioninfo}%
The output of \Rfunction{sessionInfo} on the build system 
after running this vignette.}
\end{table*}

\end{document}
