%\VignetteIndexEntry{An Introduction to IRanges}
%\VignetteDepends{}
%\VignetteKeywords{Ranges}
%\VignettePackage{IRanges}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\IRanges}{\Rpackage{IRanges}}

\title{An Introduction to \IRanges{}}
\author{Patrick Aboyoun, Michael Lawrence, Herv\'e Pag\`es}
\date{\today}

\begin{document}

\maketitle

<<options,echo=FALSE>>=
options(width=72)
@

\section{Introduction}

The \IRanges{} package is designed to represent sequences, ranges
representing indices along those sequences, and data related to those
ranges. In this vignette, we will rely on simple, illustrative example
datasets, rather than large, real-world data, so that each data structure
and algorithm can be explained in an intuitive, graphical manner. We
expect that packages that apply \IRanges{} to a particular problem domain
will provide vignettes with relevant, realistic examples.

The term \textit{sequence} in the \IRanges{} package is used rather loosely,
much like the term \textit{vector} is in \R{}. We use sequence to mean an
indexed collection of elements or objects. This differs from the standard
mathematical definition of a logically ordered collection of elements. We
will refer to the latter definition as a \textit{mathematical sequence} to
minimize the confusion.

The \IRanges{} package is available at bioconductor.org and can be
downloaded via \Rfunction{biocLite}:

<<biocLite, eval=FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("IRanges")
@
<<initialize, results=hide>>=
library(IRanges)
@

\section{Sequences}

The \IRanges{} packages represents three types of objects as sequences:
mathematical sequences, lists, and data tables (so they behave like \R{}'s
\Rclass{data.frame} objects). The following subsections describe each in
turn. All \IRanges{}-derived sequences inherit from the \Rclass{Sequence}
virtual class.

\subsection{Mathematical Sequences}

As mentioned in the introduction, a mathematical sequence is a logically
ordered collection of elements. In \R{}, mathematical sequences are
typically stored in atomic vectors. The \IRanges{} package includes two
additional mathematical sequence object types:  \Rclass{Rle}, which
compresses a mathematical sequence through run-length encoding, and
\Rclass{XSequence}, which refers to its data through an external
pointer. \Rclass{XSequence} and its derivatives are considered low-level
infrastructure and, as such, will not be covered by this vignette.

We begin our discussion of mathematical sequences using two \R{} 
\Rclass{integer} vectors.
<<initialize>>=
set.seed(0)
lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500), seq(10, 0.001, length = 500))
xVector <- rpois(1e7, lambda)
yVector <- rpois(1e7, lambda[c(251:length(lambda), 1:250)])
@

All mathematical sequences in \R{} have three main properties: (1) a
notion of length or number of elements, (2) the ability to extract
elements to create new mathematical sequences, and (3) the ability to be
combined with one or more mathematical sequences to form larger
mathematical sequences. The main functions for these three operations are
\Rfunction{length}, \Rfunction{[}, and \Rfunction{c}.
<<basic-ops>>=
length(xVector)
xVector[1]
zVector <- c(xVector, yVector)
@

While these three methods may seem trivial, they provide a great deal of
power and many mathematical sequence manipulations can be constructed
using them.

\subsubsection{Mathematical Sequence Extraction}

As with ordinary \R{} atomic vectors, it is often necessary to extract one
mathematical sequence from another. When this extraction doesn't change the
order of the elements being extracted, the result is called a
mathematical \textit{subsequence}. In general, the \Rfunction{[} function
can be used to construct a new mathematical sequence or extract a
mathematical subsequence, but often times it isn't convenient or
performant enough for the use case at hand. To compensate for this, the
\IRanges{} package supports six additional functions for mathematical
sequence extraction:

\begin{enumerate}
\item \Rfunction{window} - Produces a mathematical subsequence over a
  specified region with or without regular interval subsampling.
\item \Rfunction{seqextract} - Concatenates multiple consecutive
  mathematical subsequences into a new mathematical subsequence. The result
  may or may not be a mathematical subsequence.
\item \Rfunction{head} - Extracts a consecutive mathematical subsequence
  containing the first n elements.
\item \Rfunction{tail} - Extracts a consecutive mathematical subsequence
  containing the last n elements.
\item \Rfunction{rev} - Creates a new mathematical sequence with the
  elements in the reverse order.
\item \Rfunction{rep} - Creates a new mathematical sequence by repeating
  mathematical sequence elements.
\end{enumerate}

The following code illustrates how these functions are used on an
ordinary \R{} \Rclass{integer} vector:

<<seq-extraction>>=
xSnippet <- window(xVector, start = 4751, end = 4760)
xSnippet
head(xSnippet)
rev(xSnippet)
window(xSnippet, delta = 2)
seqextract(xSnippet, start = c(6,1), end = c(10, 5))
rep(xSnippet, 2)
@

\subsubsection{Looping over Mathematical Subsequences}

In \R{}, \Rfunction{for} looping can be an expensive operation. To
compensate for this, \IRanges{} provides two functions,
\Rfunction{aggregate} and \Rfunction{shiftApply}, to perform calculations
over mathematical subsequences. The \Rfunction{aggregate} function combines
mathematical sequence extraction functionality of the \Rfunction{window}
function with looping capabilities of the \Rfunction{sapply} function. For
example, here is some code to generate medians across a moving window of
width 3 using the \Rfunction{aggregate}:

<<aggregate>>=
xSnippet
aggregate(xSnippet, start = 1:8, width = 3, FUN = median)
@

The \Rfunction{shiftApply} function is a looping operation involving two
mathematical sequences whose elements are lined up via a positional shift
operation. For example, the elements of \Robject{xVector} and
\Robject{yVector} were simulated from Poisson distributions with the mean
of element i from \Robject{yVector} being equivalent to the mean of element
i + 250 from \Robject{xVector}. This amount of the shift can be estimated
by finding the shift that maximizes the correction between
\Robject{xVector} and \Robject{yVector}.

<<shiftApply-cor>>=
cor(xVector, yVector)
shiftApply(249:251, yVector, xVector, FUN = cor)
@

\subsubsection{Run Length Encoding}

Up until this point we have used \R{} atomic vectors to represent
mathematical sequences, but there are times when these object become too
large to manage in memory. When there are lots of consecutive repeats in
the mathematical sequence, the data can be compressed and managed in memory
through a run-length encoding where a data value is paired with a run
length. For example, the sequence \{1, 1, 1, 2, 3,  3\} can be represented
as values = \{1, 2, 3\}, lengths = \{3, 1, 2\}.

The \Rclass{Rle} class in \IRanges{} is used to represent a run-length
encoded (compressed) mathematical sequence of \Rclass{logical},
\Rclass{integer}, \Rclass{numeric}, \Rclass{complex},  \Rclass{character},
or \Rclass{raw} values. One way to construct an \Rclass{Rle} object is
through the \Rclass{Rle} constructor function:

<<Rle-construction>>=
xRle <- Rle(xVector)
yRle <- Rle(yVector)
xRle
yRle
@

When there are lots of consecutive repeats, the memory savings through
an RLE can be quite dramatic. For example, the \Robject{xRle} object
occupies less than one quarter the space of the original \Robject{xVector}
object, while storing the same information:

<<Rle-vector-compare>>=
as.vector(object.size(xRle) / object.size(xVector))
identical(as.vector(xRle), xVector)
@

The functions \Rfunction{runValue} and \Rfunction{runLength} extract
the run values and run lengths from an \Rclass{Rle} object respectively:

<<Rle-accessors>>=
head(runValue(xRle))
head(runLength(xRle))
@

The \Rclass{Rle} class supports many of the basic methods associated with
\R{} atomic vectors including the Ops, Math, Math2, Summary, and Complex
group generics. Here is a example of manipulating \Rclass{Rle} objects
using methods from the Ops group:

<<Rle-ops>>=
xRle > 0
xRle + yRle
xRle > 0 | yRle > 0
@

Here are some from the Summary group:

<<Rle-summary>>=
range(xRle)
sum(xRle > 0 | yRle > 0)
@

And here is one from the Math group:

<<Rle-math>>=
log1p(xRle)
@

As with the atomic vectors, the \Rfunction{cor} and \Rfunction{shiftApply}
functions operate on \Rclass{Rle} objects:

<<Rle-cor>>=
cor(xRle, yRle)
shiftApply(249:251, yRle, xRle, FUN = function(x, y) var(x, y) / (sd(x) * sd(y)))
@

For more information on the methods supported by the \Rclass{Rle} class,
consult the \Rcode{Rle} man page.

\subsection{Lists}

\subsubsection{Basic operations}

One often wants to organize and manipulate multiple sequences
simultaneously. We could place multiple \Rclass{Rle} instances, for
example, into a list. However, a list is too generic; it does not
confer any information about the specific class of its elements. There
is no type safety, and it is not possible to define methods
specifically for homogeneous lists with elements of a particular
class. For example, for a list of \Rclass{Rle} objects, we may wish to
define a method that retrieves the run values for each element,
without special type checking. To enable this, we define a specific
collection class, \Rclass{RleList}, for storing \Rclass{Rle} objects.

%% EXAMPLE (construct RleList)

In fact, we have done the same for many of the other classes in
\IRanges{}, as well as the base atomic vectors (raw, logical,
integer, numeric, complex and character). All of the collection
classes derive from the virtual class \Rclass{Sequence}, the
derivatives of which are all obligated to support two basic list
operations: element extraction and length retrieval.

%% EXAMPLE (element extraction, length)

Most collection types, including \Rclass{RleList}, derive from
\Rclass{TypedList}, a \Rclass{Sequence} derivative that implements
the requisite operations, as well as a number of additional
features. These include familiar list functions, such as
\Rfunction{c} and \Rfunction{lapply}.

%% EXAMPLE (c, lapply)

\subsubsection{Annotated Lists} 

Often when one has a collection of objects, there is a need to attach
metadata that describes the collection in some way. The
\Rclass{AnnotatedList} class extends \Rclass{TypedList} to add two
metadata components: an ordinary \Rclass{list} to hold arbitary
objects, called \Robject{metadata}, and \Robject{elementMetadata}, a
data frame with one row per element and any number of columns. Many of
the high-level list objects in \IRanges{} (described later) are
\Rclass{AnnotatedList} objects.

\subsubsection{Advanced Notes}

%% Perhaps this belongs in a separate advanced vignette or the paper?

\Rclass{TypedList} also provides some more advanced features. First,
as its name suggests, subclasses of \Rclass{TypedList} can specify a
type from which the class of each of its elements must inherit. For
example, \Rclass{RleList} directs \Rclass{TypedList} to ensure that
all of its elements are \Rclass{Rle} objects. One benefit of this type
safety is that it allows methods dispatching on \Rclass{RleList} to
assume that all of the elements are really of class \Rclass{Rle}.

A second advanced feature of \Rclass{TypedList} relates to its
internal representation. Behind the scenes, \Rclass{TypedList} is
simply an R \Rclass{list}. By default, there is a one-to-one mapping
between elements of the \Rclass{TypedList} and elements in the
\Rclass{list}. This is a simple design; however, it is not always
ideal. If one has many, small objects, the storage overhead,
especially for S4 objects, would be relatively high. Our solution is
to \textit{compress} the list by concatenating the elements together,
if possible. This forms a single, long element that is virtually split
by the \Rclass{TypedList} interface. A beneficial side effect of this
approach is that unlisting (concatenating all of the elements)
is cheap, as it reduces to returning the internal representation.


\subsection{Data Tables}

\Rclass{DataFrame}
\Rclass{DataFrameList}
\Rclass{SplitXDataFrameList}

\section{Sequence Ranges}

When analyzing sequences, we are often interested in specific
segments, or consecutive subsequences, of the sequence. It is not
uncommon for an analysis task to focus only on the segments
themselves, while ignoring the underlying sequence values. A
consecutive list of indices would be a simple way to select a
consecutive subsequence. However, a sparser representation would be a
a range, a pairing of a start position and a width, as used when
extracting sequences with \Rfunction{window} and
\Rfunction{seqextract}, above.

When analyzing subsequences in \IRanges{}, each range is treated as an
observation. The virtual \Rclass{Ranges} class represents lists of
ranges, or, equivalently, sequences of consecutive integers. The most
commonly used implementation of \Rclass{Ranges} is \Rclass{IRanges},
which stores the starts and widths as ordinary integer vectors. To
construct an \Rclass{IRanges} instance, we call the
\Rfunction{IRanges} constructor. Ranges are normally specified by
passing two out of the three parameters: start, end and width (see
\Sexpr{help(IRanges)} for more information).

%% Example: IRanges() with different SEW combinations

Accessing the starts, widths and ends is supported by every
\Rclass{Ranges} implementation.

%% Example: start(), width(), end()

For \Rclass{IRanges} and some other \Rclass{Ranges} derivatives,
subsetting is also supported.

%% Example: Ranges subsetting

\subsection{Normality}

\Rclass{NormalIRanges}

\subsection{Lists of Ranges}

\Rclass{RangesList}
\Rclass{IRangesList}
\Rclass{MaskCollection} % make distinction with RangesList

\subsection{Sequence Extraction}

As \Rclass{Ranges} objects encode subsequences, they may be used
directly in sequence extraction. Note that when a \textit{normal}
\Rclass{Ranges} is given as the index, the result is a true
subsequence, in the mathematical sense.

%% EXAMPLE: window() and [ with Ranges

\subsection{Transforming Ranges}

% most utilities fall in here

\paragraph{Making ranges normal}

\Rfunction{reduce}

\paragraph{Making ranges disjoint}

\Rfunction{disjoin}, \Rfunction{disjointBins}

\paragraph{Adjusting starts, ends and widths}

\Rfunction{shift}
\Rfunction{*} % zooming
\Rfunction{narrow} % like 'pintersect'
\Rfunction{threebands} % like 'pdisjoin', if it existed

\paragraph{Other transformations}

\Rfunction{restrict} % like 'intersect'
\Rfunction{reflect}
\Rfunction{flank}

\subsection{Set Operations}

\Rfunction{gaps}, \Rfunction{pgaps}
\Rfunction{setdiff}, \Rfunction{psetdiff}
\Rfunction{union}, \Rfunction{punion}
\Rfunction{intersect}, \Rfunction{pintersect}

\subsection{Finding Overlapping Ranges}

\Rclass{RangesMatching}
\Rclass{RangesMatchingList}
\Rclass{IntervalTree}
% need an IntervalTreeList?

\Rfunction{overlap}, \Rfunction{\%in\%}

\subsection{Finding Neighboring Ranges}

\Rfunction{nearest}, \Rfunction{precede}, \Rfunction{follow}

\subsection{Mapping Ranges Between Sequences}

\Rclass{RangesMapping}
\Rfunction{map}

\section{Sequence Views}

When we extract a sequence with \Rfunction{seqextract}, we can pass
multiple ranges, each selecting a single consecutive
subsequence. Those subsequences are extracted and concatenated into a
single sequence. There are many cases where the user wishes to avoid
the concatenation step and instead treat each consecutive subsequence
as a separate element in a list.  

While one could simply store each extracted sequence as an element in
a list object like a \Rclass{TypedList}, this is undesirable for a
couple of reasons. First, the user often wants to preserve the
original sequence and declare a set of interesting regions as an
overlay. This allows retrieving sequence values even after the ranges
have been adjusted. Another benefit of an overlay approach is
performance: the sequence values need not be copied.

For representing such an overlay, the \IRanges{} package provides the
virtual \Rclass{Views} class, which derives from \Rclass{Ranges} but
also stores a sequence. Each range is said to represent a
\textit{view} onto the sequence.

Here, we will demonstrate the \Rclass{RleViews} class, where the
sequence is of class \Rclass{Rle}. Other \Rclass{Views}
implementations exist, such as \Rclass{XStringViews} in the
\Rpackage{Biostrings} package.

\subsection{Manipulating Views}

\subsection{Aggregating Views}


\section{Sequence Ranges with Data Tables}

\Rclass{RangedData}
\Rclass{RangedDataList}

\subsection{Applying Over Spaces}

\Rclass{RDApplyParams}
\Rclass{FilterRules}

%% Classes Not Covered (16)
%%\Rclass{ANYTHING}
%%\Rclass{characterORNULL}
%%\Rclass{expressionORfunction}
%%\Rclass{expressionORlanguage}
%%\Rclass{functionORNULL}
%%\Rclass{IntegerPtr}
%%\Rclass{NumericPtr}
%%\Rclass{RangesORmissing}
%%\Rclass{RawPtr}
%%\Rclass{SequencePtr}
%%\Rclass{vectorORfactor}
%%\Rclass{DataFrameORNULL}
%%\Rclass{XInteger}
%%\Rclass{XIntegerORNULL}
%%\Rclass{XIntegerViews}
%%\Rclass{XNumeric}

\begin{table*}[tbp]
\begin{minipage}{\textwidth}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@ 
\end{minipage}
\caption{\label{tab:sessioninfo}%
The output of \Rfunction{sessionInfo} on the build system 
after running this vignette.}
\end{table*}

\end{document}
