Immediate TODO list
---------

- Rename "narrow" method for MaskCollection objects "subseq" (this reflects
  better what it really does).

Long term TODO list
-------------------

- Data structures:
  - RectRanges, container of two Ranges, one for each dimension
  - PolyRanges, list of real-valued matrices, each holding one polygon?
  - ViewsList, extends RangesList but specific to Views
  - XDataFrame, add annotations (like AnnotatedDataFrame)
  
- Ranges methods:
  - "unique" for removing duplicate ranges
  - "findInterval" for points that fall into a normal Ranges
  - "nearest" for finding nearest neighbors
  - "match" and "%in%" for exact matching
  - "intersect" or "&" for finding the completely overlapping subregions
  - "setdiff" or "-" for subtracting the overlap from first argument
  - "!" as alias for "gaps"
  - "union" or "|" for merging, i.e. reduce(c(x, y))
  - "reduce" should take a window argument
  - "inverse.rle", generates vector from values on ranges
    - if no value specified, could be logical vector, TRUE in range else FALSE
  - "sort" sorts by start or end

- TypedList methods:
  - split() for splitting
  - dim, dim<-, dimnames, dimnames<- for multi-dimensional list (like 'by')
  
- RangesList methods:
  - parallel rbind/cbind
  - binary ops: "overlap", "nearest", "intersect", "setdiff", "merge"
    - 'y' omitted: become n-ary ops on items in collection
    - 'y' specified: performed element-wise
  - unary ops: "gaps", "coverage", "slice", etc are vectorized
  
- RangeMatching methods:
  - "matched" which matched in query
  - "as.matrix", to extract matches
  - "clusters", to group matched ranges
  - "relations" to extract relationships in terms of Allen's Interval Algebra
    - kind of like "all.equal"
  - "width" for amount of overlap for each match
    
- IRanges constructors:
  - From 'rle' object

- XDataFrame methods
  - group generics (Math, Ops, Summary)
  - by, aggregate
  - with, within
  - subset

- RangedData methods:
  - rbind: inner combine
  
- XDataFrameList methods
  - stack: unlist(), but with factors recording source of each row

- IntervalTree:
  - instead of dense lgeMatrix, just complement the lgCMatrix