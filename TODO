Immediate TODO list
---------

Long term TODO list
-------------------

- Ranges:
  - "unique" for removing duplicate ranges
  - "match" for exact matching
  - operator aliases
    - ranges & ranges (intersection)
    - ranges | ranges (union)
    - !ranges (complement/gaps)
    - ranges - ranges (setdiff)
  - "inverse.rle", opposite of whichAsIRanges
  - "range" returns a single element IRanges with bounds of entire set
  - permute or something to create a random mimic

- IRanges:
  - should probably use XIntegers for start/width
  
- TypedList:
  - refactor to simplify internals
  - dim, dim<-, dimnames, dimnames<- for multi-dimensional list (like 'by')
  
- RangesList:
  - parallel rbind
  - binary ops: "overlap", "nearest", "intersect", "setdiff", "merge"
    - 'y' omitted: become n-ary ops on items in collection
    - 'y' specified: performed element-wise
  - unary ops: "gaps", "coverage", "slice", etc are vectorized
    
- XDataFrame:
  - group generics (Math, Ops, Summary)
  - by, aggregate
  - with, within
  - subset

- RangedData:
  - merge for SQL-type join operations based on range overlap
  - inverse.rle
  - "aggregate", generalization of coverage for max/min/etc
  - as a subset specification for BSGenome objects (get sequences out)

- SplitXDataFrame:
  - unlist() should add a factor column recording source of each row
  - rbind
  
- IntervalTree:
  - overlap: consider returning a doublet matrix instead of non-zero pattern
  - look into nested containment lists

- FilterRules:
  - refactor, using ShortRead filter framework (becomes FilterList)
  - support subsetting XDataFrame/RangedData directly

- rdapply:
  - probably need to add 'excludePattern' parameter
  
- IO:
  - xscan() - read data directly into XSequence objects
  - move chain reading to rtracklayer
